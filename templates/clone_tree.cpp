/*
 Do not modify, auto-generated by model_gen.tcl

 Copyright 2019-2020 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   clone_tree.cpp
 * Author:
 *
 * Created on December 14, 2019, 10:03 PM
 */
#include <uhdm/ElaboratorListener.h>
#include <uhdm/ExprEval.h>
#include <uhdm/RTTI.h>
#include <uhdm/clone_tree.h>
#include <uhdm/uhdm.h>

using namespace UHDM;

namespace UHDM {

BaseClass* clone_tree(const BaseClass* root, Serializer& s,
                      ElaboratorListener* elaborator) {
  return root ? root->DeepClone(&s, elaborator, nullptr) : nullptr;
}

tf_call* sys_func_call::DeepClone(Serializer* serializer,
                                  ElaboratorListener* elaborator,
                                  BaseClass* parent) const {
  sys_func_call* const clone = serializer->MakeSys_func_call();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = User_systf())
    clone->User_systf(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Scope())
    clone->Scope(obj->DeepClone(serializer, elaborator, clone));
  if (auto vec = Tf_call_args()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Tf_call_args(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto obj = Typespec())
    clone->Typespec(obj->DeepClone(serializer, elaborator, clone));

  return clone;
}

tf_call* sys_task_call::DeepClone(Serializer* serializer,
                                  ElaboratorListener* elaborator,
                                  BaseClass* parent) const {
  sys_task_call* const clone = serializer->MakeSys_task_call();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = User_systf())
    clone->User_systf(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Scope())
    clone->Scope(obj->DeepClone(serializer, elaborator, clone));
  if (auto vec = Tf_call_args()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Tf_call_args(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto obj = Typespec())
    clone->Typespec(obj->DeepClone(serializer, elaborator, clone));

  return clone;
}

tf_call* method_func_call::DeepClone(Serializer* serializer,
                                     ElaboratorListener* elaborator,
                                     BaseClass* parent) const {
  const expr* prefix = Prefix();
  if (prefix) {
    prefix = prefix->DeepClone(serializer, elaborator, (BaseClass*)this);
  }
  bool is_function = elaborator->isFunctionCall(VpiName(), prefix);
  tf_call* the_clone = nullptr;
  if (is_function) {
    method_func_call* const clone = serializer->MakeMethod_func_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    if (auto obj = Prefix())
      clone->Prefix(obj->DeepClone(serializer, elaborator, clone));
    const ref_obj* ref = any_cast<const ref_obj*>(clone->Prefix());
    const class_var* prefix = nullptr;
    if (ref) prefix = any_cast<const class_var*>(ref->Actual_group());
    elaborator->scheduleTaskFuncBinding(clone, prefix);
    any* pushedVar = nullptr;
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        any* arg = obj->DeepClone(serializer, elaborator, clone);
        // CB callbacks_to_append[$];
        // unique_callbacks_to_append = callbacks_to_append.unique( cb_ ) with ( cb_.get_inst_id );
        if (parent->UhdmType() == uhdmhier_path) {
          hier_path* phier = (hier_path*) parent;
          any* last = phier->Path_elems()->back();
          if (last->UhdmType() == uhdmref_obj) {
            ref_obj* last_ref = (ref_obj*) last;
            if (const any* actual = last_ref->Actual_group()) {
              if (arg->UhdmType() == uhdmref_obj) {
                ref_obj* refarg = (ref_obj*) arg;
                bool override = false;
                if (const any* act = refarg->Actual_group()) {
                  if (act->VpiName() == obj->VpiName()) {
                    override = true;
                  }
                } else {
                   override = true;
                }
                if (override) {
                  if (actual->UhdmType() == uhdmarray_var) {
                    array_var* arr = (array_var*)actual;
                    for (variables* var : *arr->Variables()) {
                      variables* clone =
                          (variables*)clone_tree(var, *serializer, elaborator);
                      clone->VpiName(obj->VpiName());
                      actual = clone;
                      elaborator->pushVar(clone);
                      pushedVar = clone;
                      break;
                    }
                  }
                  refarg->Actual_group((any*)actual);
                }
              }
            } 
          }
        }
        clone_vec->push_back(arg);
      }
    }
    if (auto obj = With())
      clone->With(obj->DeepClone(serializer, elaborator, clone));
    if (pushedVar) {
      elaborator->popVar(pushedVar);
    }
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  } else {
    method_task_call* const clone = serializer->MakeMethod_task_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    //*clone = *this;
    clone->VpiName(VpiName());
    clone->Tf_call_args(Tf_call_args());
    clone->UhdmId(id);
    clone->VpiParent(parent);
    clone->VpiFile(VpiFile());
    clone->VpiLineNo(VpiLineNo());
    clone->VpiColumnNo(VpiColumnNo());
    clone->VpiEndLineNo(VpiEndLineNo());
    clone->VpiEndColumnNo(VpiEndColumnNo());
    if (auto obj = Prefix())
      clone->Prefix(obj->DeepClone(serializer, elaborator, clone));
    const ref_obj* ref = any_cast<const ref_obj*>(clone->Prefix());
    const class_var* prefix = nullptr;
    if (ref) prefix = any_cast<const class_var*>(ref->Actual_group());
    elaborator->scheduleTaskFuncBinding(clone, prefix);
    if (auto obj = With())
      clone->With(obj->DeepClone(serializer, elaborator, clone));
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  }
  return the_clone;
}

constant* constant::DeepClone(Serializer* serializer,
                              ElaboratorListener* elaborator,
                              BaseClass* parent) const {
  if (elaborator->uniquifyTypespec() || (VpiSize() == -1)) {
    constant* const clone = serializer->MakeConstant();
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
    return clone;
  } else {
    return (constant*)this;
  }
}

tagged_pattern* tagged_pattern::DeepClone(Serializer* serializer,
                                          ElaboratorListener* elaborator,
                                          BaseClass* parent) const {
  if (elaborator->uniquifyTypespec()) {
    tagged_pattern* const clone = serializer->MakeTagged_pattern();
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
    if (auto obj = Pattern())
      clone->Pattern(obj->DeepClone(serializer, elaborator, clone));
    return clone;
  } else {
    return (tagged_pattern*)this;
  }
}

tf_call* method_task_call::DeepClone(Serializer* serializer,
                                     ElaboratorListener* elaborator,
                                     BaseClass* parent) const {
  const expr* prefix = Prefix();
  if (prefix) {
    prefix = prefix->DeepClone(serializer, elaborator, (BaseClass*)this);
  }
  bool is_task = elaborator->isTaskCall(VpiName(), prefix);
  tf_call* the_clone = nullptr;
  if (is_task) {
    method_task_call* const clone = serializer->MakeMethod_task_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    if (auto obj = Prefix())
      clone->Prefix(obj->DeepClone(serializer, elaborator, clone));
    const ref_obj* ref = any_cast<const ref_obj*>(clone->Prefix());
    const class_var* prefix = nullptr;
    if (ref) prefix = any_cast<const class_var*>(ref->Actual_group());
    elaborator->scheduleTaskFuncBinding(clone, prefix);
    if (auto obj = With())
      clone->With(obj->DeepClone(serializer, elaborator, clone));
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  } else {
    method_func_call* const clone = serializer->MakeMethod_func_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    //*clone = *this;
    clone->VpiName(VpiName());
    clone->Tf_call_args(Tf_call_args());
    clone->UhdmId(id);
    clone->VpiParent(parent);
    clone->VpiFile(VpiFile());
    clone->VpiLineNo(VpiLineNo());
    clone->VpiColumnNo(VpiColumnNo());
    clone->VpiEndLineNo(VpiEndLineNo());
    clone->VpiEndColumnNo(VpiEndColumnNo());
    if (auto obj = Prefix())
      clone->Prefix(obj->DeepClone(serializer, elaborator, clone));
    const ref_obj* ref = any_cast<const ref_obj*>(clone->Prefix());
    const class_var* prefix = nullptr;
    if (ref) prefix = any_cast<const class_var*>(ref->Actual_group());
    elaborator->scheduleTaskFuncBinding(clone, prefix);
    if (auto obj = With())
      clone->With(obj->DeepClone(serializer, elaborator, clone));
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  }
  return the_clone;
}

tf_call* func_call::DeepClone(Serializer* serializer,
                              ElaboratorListener* elaborator,
                              BaseClass* parent) const {
  bool is_function = elaborator->isFunctionCall(VpiName(), nullptr);
  tf_call* the_clone = nullptr;
  if (is_function) {
    func_call* const clone = serializer->MakeFunc_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    elaborator->scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  } else {
    task_call* const clone = serializer->MakeTask_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    //*clone = *this;
    clone->VpiName(VpiName());
    clone->Tf_call_args(Tf_call_args());
    clone->UhdmId(id);
    clone->VpiParent(parent);
    clone->VpiFile(VpiFile());
    clone->VpiLineNo(VpiLineNo());
    clone->VpiColumnNo(VpiColumnNo());
    clone->VpiEndLineNo(VpiEndLineNo());
    clone->VpiEndColumnNo(VpiEndColumnNo());
    elaborator->scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  }

  return the_clone;
}

tf_call* task_call::DeepClone(Serializer* serializer,
                              ElaboratorListener* elaborator,
                              BaseClass* parent) const {
  bool is_task = elaborator->isTaskCall(VpiName(), nullptr);
  tf_call* the_clone = nullptr;
  if (is_task) {
    task_call* const clone = serializer->MakeTask_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    *clone = *this;
    clone->UhdmId(id);
    clone->VpiParent(parent);
    elaborator->scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  } else {
    func_call* const clone = serializer->MakeFunc_call();
    the_clone = clone;
    const unsigned long id = clone->UhdmId();
    //*clone = *this;
    clone->VpiName(VpiName());
    clone->VpiFile(VpiFile());
    clone->VpiLineNo(VpiLineNo());
    clone->VpiColumnNo(VpiColumnNo());
    clone->VpiEndLineNo(VpiEndLineNo());
    clone->VpiEndColumnNo(VpiEndColumnNo());
    clone->Tf_call_args(Tf_call_args());
    clone->UhdmId(id);
    clone->VpiParent(parent);
    elaborator->scheduleTaskFuncBinding(clone, nullptr);
    if (auto obj = Scope())
      clone->Scope(obj->DeepClone(serializer, elaborator, clone));
    if (auto vec = Tf_call_args()) {
      auto clone_vec = serializer->MakeAnyVec();
      clone->Tf_call_args(clone_vec);
      for (auto obj : *vec) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      }
    }
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  }
  return the_clone;
}

gen_scope_array* gen_scope_array::DeepClone(Serializer* serializer,
                                            ElaboratorListener* elaborator,
                                            BaseClass* parent) const {
  gen_scope_array* const clone = serializer->MakeGen_scope_array();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = Gen_var())
    clone->Gen_var(obj->DeepClone(serializer, elaborator, clone));
  if (auto vec = Gen_scopes()) {
    auto clone_vec = serializer->MakeGen_scopeVec();
    clone->Gen_scopes(clone_vec);
    for (auto obj : *vec) {
      elaborator->enterGen_scope(obj, nullptr);
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      elaborator->leaveGen_scope(obj, nullptr);
    }
  }
  if (auto obj = VpiInstance())
    clone->VpiInstance(obj->DeepClone(serializer, elaborator, clone));

  return clone;
}

function* function::DeepClone(Serializer* serializer,
                              ElaboratorListener* elaborator,
                              BaseClass* parent) const {
  function* const clone = serializer->MakeFunction();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = Left_range())
    clone->Left_range(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Right_range())
    clone->Right_range(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Return()) clone->Return((variables*)obj);
  if (auto obj = Instance()) clone->Instance((instance*)obj);
  if (instance* inst = any_cast<instance*>(parent)) clone->Instance(inst);
  if (auto obj = Class_defn())
    clone->Class_defn(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Ref_obj())
    clone->Ref_obj(obj->DeepClone(serializer, elaborator, clone));
  if (auto vec = Io_decls()) {
    auto clone_vec = serializer->MakeIo_declVec();
    clone->Io_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Variables()) {
    auto clone_vec = serializer->MakeVariablesVec();
    clone->Variables(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Parameters()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Parameters(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Scopes()) {
    auto clone_vec = serializer->MakeScopeVec();
    clone->Scopes(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Typespecs()) {
    auto clone_vec = serializer->MakeTypespecVec();
    clone->Typespecs(clone_vec);
    for (auto obj : *vec) {
      if (elaborator->uniquifyTypespec()) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      } else {
        clone_vec->push_back(obj);
      }
    }
  }
  elaborator->enterTask_func(clone, nullptr);
  if (auto vec = Concurrent_assertions()) {
    auto clone_vec = serializer->MakeConcurrent_assertionsVec();
    clone->Concurrent_assertions(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Property_decls()) {
    auto clone_vec = serializer->MakeProperty_declVec();
    clone->Property_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Sequence_decls()) {
    auto clone_vec = serializer->MakeSequence_declVec();
    clone->Sequence_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Named_events()) {
    auto clone_vec = serializer->MakeNamed_eventVec();
    clone->Named_events(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Named_event_arrays()) {
    auto clone_vec = serializer->MakeNamed_event_arrayVec();
    clone->Named_event_arrays(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Virtual_interface_vars()) {
    auto clone_vec = serializer->MakeVirtual_interface_varVec();
    clone->Virtual_interface_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Logic_vars()) {
    auto clone_vec = serializer->MakeLogic_varVec();
    clone->Logic_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Array_vars()) {
    auto clone_vec = serializer->MakeArray_varVec();
    clone->Array_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Array_var_mems()) {
    auto clone_vec = serializer->MakeArray_varVec();
    clone->Array_var_mems(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Param_assigns()) {
    auto clone_vec = serializer->MakeParam_assignVec();
    clone->Param_assigns(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Let_decls()) {
    auto clone_vec = serializer->MakeLet_declVec();
    clone->Let_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Attributes()) {
    auto clone_vec = serializer->MakeAttributeVec();
    clone->Attributes(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Instance_items()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Instance_items(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto obj = Stmt())
    clone->Stmt(obj->DeepClone(serializer, elaborator, clone));
  elaborator->leaveTask_func(clone, nullptr);
  return clone;
}

task* task::DeepClone(Serializer* serializer, ElaboratorListener* elaborator,
                      BaseClass* parent) const {
  task* const clone = serializer->MakeTask();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = Left_range())
    clone->Left_range(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Right_range())
    clone->Right_range(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Return())
    clone->Return(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Instance()) clone->Instance((instance*)obj);
  if (instance* inst = any_cast<instance*>(parent)) clone->Instance(inst);
  if (auto obj = Class_defn())
    clone->Class_defn(obj->DeepClone(serializer, elaborator, clone));
  if (auto obj = Ref_obj())
    clone->Ref_obj(obj->DeepClone(serializer, elaborator, clone));
  if (auto vec = Io_decls()) {
    auto clone_vec = serializer->MakeIo_declVec();
    clone->Io_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Variables()) {
    auto clone_vec = serializer->MakeVariablesVec();
    clone->Variables(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Scopes()) {
    auto clone_vec = serializer->MakeScopeVec();
    clone->Scopes(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Typespecs()) {
    auto clone_vec = serializer->MakeTypespecVec();
    clone->Typespecs(clone_vec);
    for (auto obj : *vec) {
      if (elaborator->uniquifyTypespec()) {
        clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
      } else {
        clone_vec->push_back(obj);
      }
    }
  }
  elaborator->enterTask_func(clone, nullptr);
  if (auto vec = Concurrent_assertions()) {
    auto clone_vec = serializer->MakeConcurrent_assertionsVec();
    clone->Concurrent_assertions(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Property_decls()) {
    auto clone_vec = serializer->MakeProperty_declVec();
    clone->Property_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Sequence_decls()) {
    auto clone_vec = serializer->MakeSequence_declVec();
    clone->Sequence_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Named_events()) {
    auto clone_vec = serializer->MakeNamed_eventVec();
    clone->Named_events(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Named_event_arrays()) {
    auto clone_vec = serializer->MakeNamed_event_arrayVec();
    clone->Named_event_arrays(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Virtual_interface_vars()) {
    auto clone_vec = serializer->MakeVirtual_interface_varVec();
    clone->Virtual_interface_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Logic_vars()) {
    auto clone_vec = serializer->MakeLogic_varVec();
    clone->Logic_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Array_vars()) {
    auto clone_vec = serializer->MakeArray_varVec();
    clone->Array_vars(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Array_var_mems()) {
    auto clone_vec = serializer->MakeArray_varVec();
    clone->Array_var_mems(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Param_assigns()) {
    auto clone_vec = serializer->MakeParam_assignVec();
    clone->Param_assigns(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Let_decls()) {
    auto clone_vec = serializer->MakeLet_declVec();
    clone->Let_decls(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Attributes()) {
    auto clone_vec = serializer->MakeAttributeVec();
    clone->Attributes(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Parameters()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Parameters(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto vec = Instance_items()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Instance_items(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (auto obj = Stmt())
    clone->Stmt(obj->DeepClone(serializer, elaborator, clone));
  elaborator->leaveTask_func(clone, nullptr);
  return clone;
}

cont_assign* cont_assign::DeepClone(Serializer* serializer,
                                    ElaboratorListener* elaborator,
                                    BaseClass* parent) const {
  cont_assign* const clone = serializer->MakeCont_assign();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto obj = Delay())
    clone->Delay(obj->DeepClone(serializer, elaborator, clone));
  expr* lhs = nullptr;
  if (auto obj = Lhs()) {
    lhs = obj->DeepClone(serializer, elaborator, clone);
    clone->Lhs(lhs);
  }
  if (auto obj = Rhs()) {
    expr* rhs = obj->DeepClone(serializer, elaborator, clone);
    clone->Rhs(rhs);
    if (lhs && lhs->UhdmType() == uhdmref_obj) {
      ref_obj* ref = (ref_obj*)lhs;
      const any* actual = ref->Actual_group();
      if (actual) {
        if (actual->UhdmType() == uhdmstruct_var) {
          struct_var* stv = (struct_var*)actual;
          ExprEval eval(elaborator->muteErrors());
          expr* res = eval.flattenPatternAssignments(*serializer, stv->Typespec(), rhs);
          if (res->UhdmType() == uhdmoperation) {
            ((operation*)rhs)->Operands(((operation*)res)->Operands());
          }
        }
      }
    }
  }
  if (auto vec = Cont_assign_bits()) {
    auto clone_vec = serializer->MakeCont_assign_bitVec();
    clone->Cont_assign_bits(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }

  return clone;
}

any* bindClassTypespec(class_typespec* ctps, any* current,
                       const std::string& name, bool& found) {
  any* previous = nullptr;
  const class_defn* defn = ctps->Class_defn();
  while (defn) {
    if (defn->Variables()) {
      for (variables* var : *defn->Variables()) {
        if (var->VpiName() == name) {
          if (current->UhdmType() == uhdmref_obj) {
            ((ref_obj*)current)->Actual_group(var);
          } else if (current->UhdmType() == uhdmbit_select) {
            const any* parent = current->VpiParent();
            if (parent && (parent->UhdmType() == uhdmref_obj))
              ((ref_obj*)parent)->Actual_group(var);
          }
          previous = var;
          found = true;
          break;
        }
      }
    }
    if (defn->Named_events()) {
      for (named_event* event : *defn->Named_events()) {
        if (event->VpiName() == name) {
          if (current->UhdmType() == uhdmref_obj) {
            ((ref_obj*)current)->Actual_group(event);
          } else if (current->UhdmType() == uhdmbit_select) {
            const any* parent = current->VpiParent();
            if (parent && (parent->UhdmType() == uhdmref_obj))
              ((ref_obj*)parent)->Actual_group(event);
          }
          previous = event;
          found = true;
          break;
        }
      }
    }
    if (defn->Task_funcs()) {
      for (task_func* tf : *defn->Task_funcs()) {
        if (tf->VpiName() == name) {
          if (current->UhdmType() == uhdmref_obj) {
            ((ref_obj*)current)->Actual_group(tf);
          } else if (current->UhdmType() == uhdmbit_select) {
            const any* parent = current->VpiParent();
            if (parent && (parent->UhdmType() == uhdmref_obj))
              ((ref_obj*)parent)->Actual_group(tf);
          } else if (current->UhdmType() == uhdmmethod_func_call) {
            if (tf->UhdmType() == uhdmfunction)
              ((method_func_call*)current)->Function((function*) tf);
          } else if (current->UhdmType() == uhdmmethod_task_call) {
            if (tf->UhdmType() == uhdmtask)
              ((method_task_call*)current)->Task((task*) tf);
          }
          previous = tf;
          found = true;
          break;
        }
      }
    }
    if (found) break;
    const class_defn* tmp = defn;
    defn = nullptr;
    if (const extends* ext = tmp->Extends()) {
      if (const class_typespec* tp = ext->Class_typespec()) {
        defn = tp->Class_defn();
      }
    }
  }
  return previous;
}

hier_path* hier_path::DeepClone(Serializer* serializer,
                                ElaboratorListener* elaborator,
                                BaseClass* parent) const {
  hier_path* const clone = serializer->MakeHier_path();
  const unsigned long id = clone->UhdmId();
  *clone = *this;
  clone->UhdmId(id);
  clone->VpiParent(parent);
  if (auto vec = Path_elems()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->Path_elems(clone_vec);
    any* previous = nullptr;
    for (auto obj : *vec) {
      any* current = nullptr;
      current = obj->DeepClone(serializer, elaborator, clone);
      clone_vec->push_back(current);
      bool found = false;
      if (current->UhdmType() == uhdmref_obj) {
        ref_obj* ref = (ref_obj*) current;
        if (current->VpiName() == "this") {
          const any* tmp = current;
          while (tmp) {
            if (tmp->UhdmType() == uhdmclass_defn) {
              ref->Actual_group((any*) tmp);
              found = true;
              break;
            }
            tmp = tmp->VpiParent();
          }
        } else if (current->VpiName() == "super") {
          const any* tmp = current;
          while (tmp) {
            if (tmp->UhdmType() == uhdmclass_defn) {
              class_defn* def = (class_defn*) tmp;
              const extends* ext = def->Extends();
              if (ext) {
                const class_typespec* ctps = ext->Class_typespec();
                if (ctps) {
                  ref->Actual_group((any*)ctps->Class_defn());
                  found = true;
                  break;
                }
              }
              break;
            }
            tmp = tmp->VpiParent();
          }
        }
      }
      if (previous) {
        std::string name = obj->VpiName();
        std::string nameIndexed = name;
        if (name.empty()) {
          if (obj->UhdmType() == uhdmpart_select) {
            if (obj->VpiParent()) name = obj->VpiParent()->VpiName();
            part_select* sel = (part_select*) obj;
            if (const any* actual = sel->Actual_group()) {
              name = actual->VpiName();
            }
          } else if (obj->UhdmType() == uhdmindexed_part_select) {
            if (obj->VpiParent()) name = obj->VpiParent()->VpiName();
            indexed_part_select* sel = (indexed_part_select*) obj;
            if (const any* actual = sel->Actual_group()) {
              name = actual->VpiName();
            }           
          } else if (obj->UhdmType() == uhdmbit_select) {
            //  a[i][j]
            bit_select* sel = (bit_select*) obj;
            if (previous->UhdmType() == uhdmbit_select) {
              bit_select* prev = (bit_select*) previous;
              sel->Actual_group((any*) prev->Actual_group());
              found = true;
            }
          }
        }
        if (obj->UhdmType() == uhdmbit_select) {
          if (const any* p = obj->VpiParent()) {
            if (p->UhdmType() == uhdmref_obj) {
              ref_obj* pr = (ref_obj*)p;
              const std::string& pname = pr->VpiName();
              if (pname.find('[') != std::string::npos) {
                nameIndexed = pname;
              }
            }
          }
          bit_select* sel = (bit_select*) obj;
          if (const any* actual = sel->Actual_group()) {
            const std::string& pname = actual->VpiName();
            if (pname.find('[') != std::string::npos) {
              nameIndexed = pname;
            }
          }
        }
        if (previous->UhdmType() == uhdmref_obj ||
            previous->UhdmType() == uhdmbit_select ||
            previous->UhdmType() == uhdmpart_select ||
            previous->UhdmType() == uhdmindexed_part_select) {
          const any* actual = nullptr;
          if (previous->UhdmType() == uhdmbit_select) {
            bit_select* sel = (bit_select*)previous;
            if (const any* p = sel->VpiParent()) {
              if (p->UhdmType() == uhdmref_obj) {
                ref_obj* pref = (ref_obj*)p;
                actual = pref->Actual_group();
              }
            }
            if (const any* actualtmp = sel->Actual_group()) {
              actual = actualtmp;
            }
          } else if (previous->UhdmType() == uhdmpart_select) {
            part_select* sel = (part_select*) obj;
            if (const any* actualtmp = sel->Actual_group()) {
              actual = actualtmp;
            }
          } else if (previous->UhdmType() == uhdmindexed_part_select) {
            indexed_part_select* sel = (indexed_part_select*) obj;
            if (const any* actualtmp = sel->Actual_group()) {
               actual = actualtmp;
            } 
          } else {
            ref_obj* ref = (ref_obj*)previous;
            actual = ref->Actual_group();
            if (actual == nullptr) {
              if (previous->VpiName() == "$root") {
                actual = elaborator->currentDesign();
              }
            }
          }
          if (actual) {
            UHDM_OBJECT_TYPE actual_type = actual->UhdmType();
            switch (actual_type) {
              case uhdmdesign: {
                design* scope = (design*) actual;
                if (scope->TopModules()) {
                  for (auto m : *scope->TopModules()) {
                    const std::string& modName = m->VpiName();
                    if (modName == name || modName == nameIndexed || modName == ("work@" + name)) {
                      found = true;
                      previous = m;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(m);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(m);
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case uhdmgen_scope: {
                gen_scope* scope = (gen_scope*)actual;
                if (obj->UhdmType() == uhdmmethod_func_call) {
                  method_func_call* call = (method_func_call*)current;
                  if (scope->Task_funcs()) {
                    for (auto tf : *scope->Task_funcs()) {
                      if (tf->VpiName() == name) {
                        call->Function(any_cast<function*>(tf));
                        previous = (any*)call->Function();
                        found = true;
                        break;
                      }
                    }
                  }
                } else if (obj->UhdmType() == uhdmmethod_task_call) {
                  method_task_call* call = (method_task_call*)current;
                  if (scope->Task_funcs()) {
                    for (auto tf : *scope->Task_funcs()) {
                      if (tf->VpiName() == name) {
                        call->Task(any_cast<task*>(tf));
                        found = true;
                        previous = (any*)call->Task();
                        break;
                      }
                    }
                  }
                } else {
                  if (scope->Modules()) {
                    for (auto m : *scope->Modules()) {
                      if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(m);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(m);
                        }
                        break;
                      }
                    }
                  }
                  if (scope->Nets()) {
                    for (auto m : *scope->Nets()) {
                      if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(m);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(m);
                        }
                        break;
                      }
                    }
                  }
                  if (scope->Array_nets()) {
                    for (auto m : *scope->Array_nets()) {
                      if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(m);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(m);
                        }
                        break;
                      }
                    }
                  }
                  if (scope->Variables()) {
                    for (auto m : *scope->Variables()) {
                      if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                        found = true;
                        previous = m;
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(m);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(m);
                        }
                        break;
                      }
                    }
                  }
                }
                break;
              }
              case uhdmmodport: {
                UHDM::modport* modport = (UHDM::modport*)actual;
                if (modport->Io_decls()) {
                  for (io_decl* decl : *modport->Io_decls()) {
                    if (decl->VpiName() == name) {
                      found = true;
                      previous = decl;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(decl);
                      }
                    }
                  }
                }
                break;
              }
              case uhdmnamed_event: {
                if (name == "triggered") {
                  // Builtin
                  found = true;
                }
                break;
              }
              case uhdmarray_net: {
                array_net* anet = (array_net*)actual;
                VectorOfnet* vars = anet->Nets();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->UhdmType();
                }
                if (name == "size" || name == "exists" || name == "find" ||
                    name == "max" || name == "min") {
                  func_call* call = serializer->MakeFunc_call();
                  call->VpiName(name);
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (any*)call;
                } else if (name == "") {
                  // One of the Index(es)
                  found = true;
                }
                break;
              }
              case uhdmarray_var: {
                array_var* avar = (array_var*)actual;
                VectorOfvariables* vars = avar->Variables();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->UhdmType();
                }
                if (name == "size" || name == "exists" || name == "find" ||
                    name == "max" || name == "min") {
                  func_call* call = serializer->MakeFunc_call();
                  call->VpiName(name);
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (any*)call;
                } else if (name == "") {
                  // One of the Index(es)
                  found = true;
                }
                break;
              }
              case uhdmpacked_array_var: {
                packed_array_var* avar = (packed_array_var*)actual;
                VectorOfany* vars = avar->Elements();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->UhdmType();
                }
                if (name == "size" || name == "exists" || name == "exists" ||
                    name == "max" || name == "min") {
                  func_call* call = serializer->MakeFunc_call();
                  call->VpiName(name);
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (any*)call;
                }
                break;
              }
              case uhdmpacked_array_net: {
                packed_array_net* avar = (packed_array_net*)actual;
                VectorOfany* vars = avar->Elements();
                if (vars && vars->size()) {
                  actual = vars->at(0);
                  actual_type = actual->UhdmType();
                }
                if (name == "size" || name == "exists" || name == "exists" ||
                    name == "max" || name == "min") {
                  func_call* call = serializer->MakeFunc_call();
                  call->VpiName(name);
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(call);
                  }
                  // Builtin method
                  found = true;
                  previous = (any*)call;
                }
                break;
              }
              case uhdmnamed_begin: {
                named_begin* begin = (named_begin*)actual;
                if (begin->Variables()) {
                  for (auto m : *begin->Variables()) {
                    if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                      found = true;
                      previous = m;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(m);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(m);
                      }
                      break;
                    }
                  }
                }
                if (begin->Array_vars()) {
                  for (auto m : *begin->Array_vars()) {
                    if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                      found = true;
                      previous = m;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(m);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(m);
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case uhdmnamed_fork: {
                named_fork* begin = (named_fork*)actual;
                if (begin->Variables()) {
                  for (auto m : *begin->Variables()) {
                    if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                      found = true;
                      previous = m;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(m);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(m);
                      }
                      break;
                    }
                  }
                }
                if (begin->Array_vars()) {
                  for (auto m : *begin->Array_vars()) {
                    if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                      found = true;
                      previous = m;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(m);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(m);
                      }
                      break;
                    }
                  }
                }
                break;
              }
              default:
                break;
            }

            switch (actual_type) {
              case uhdmclocking_block: {
                clocking_block* block = (clocking_block*)actual;
                if (block->Clocking_io_decls()) {
                  for (clocking_io_decl* decl : *block->Clocking_io_decls()) {
                    if (decl->VpiName() == name) {
                      found = true;
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(decl);
                        previous = (any*)decl;
                      }
                    }
                  }
                }
                break;
              }
              case uhdmmodule: {
                module_inst* mod = (module_inst*)actual;
                if (mod->Variables()) {
                  for (variables* var : *mod->Variables()) {
                    if (var->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(var);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(var);
                      }
                      previous = var;
                      found = true;
                      break;
                    }
                  }
                }

                if (mod->Nets()) {
                  for (nets* n : *mod->Nets()) {
                    if (n->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(n);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(n);
                      }
                      previous = n;
                      found = true;
                      break;
                    }
                  }
                }
                if (mod->Modules()) {
                  for (auto m : *mod->Modules()) {
                    if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                      found = true;
                      previous = m;
                      break;
                    }
                  }
                }
                if (mod->Gen_scope_arrays()) {
                  for (auto gsa : *mod->Gen_scope_arrays()) {
                    if (gsa->VpiName() == name ||
                        gsa->VpiName() == nameIndexed) {
                      for (auto gs : *gsa->Gen_scopes()) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(gs);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(gs);
                        }
                        previous = gs;
                        found = true;
                        break;
                      }
                    }
                  }
                }
                break;
              }
              case uhdmclass_var: {
                const typespec* tps = ((class_var*)actual)->Typespec();
                if (tps) {
                  UHDM_OBJECT_TYPE ttype = tps->UhdmType();
                  if (ttype == uhdmclass_typespec) {
                    class_typespec* ctps = (class_typespec*)tps;
                    any* tmp = bindClassTypespec(ctps, current, name, found);
                    if (found) {
                      previous = tmp;
                    }
                  } else if (ttype == uhdmstruct_typespec) {
                    struct_typespec* stpt = (struct_typespec*)tps;
                    for (typespec_member* member : *stpt->Members()) {
                      if (member->VpiName() == name) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(member);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                  }
                }
                if (current->UhdmType() == uhdmmethod_func_call) {
                  found = true;
                }
                break;
              }
              case uhdmstruct_net:
              case uhdmstruct_var: {
                struct_typespec* stpt = nullptr;
                if (actual->UhdmType() == uhdmstruct_net) {
                  stpt = (struct_typespec*)((struct_net*)actual)->Typespec();
                } else if (actual->UhdmType() == uhdmstruct_var) {
                  stpt = (struct_typespec*)((struct_var*)actual)->Typespec();
                }
                if (stpt) {
                  for (typespec_member* member : *stpt->Members()) {
                    if (member->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(member);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        ((bit_select*)current)->Actual_group(member);
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                }
                break;
              }
              case uhdmunion_var: {
                union_typespec* stpt =
                    (union_typespec*)((union_var*)actual)->Typespec();
                if (stpt) {
                  for (typespec_member* member : *stpt->Members()) {
                    if (member->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(member);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                }
                break;
              }
              case uhdminterface: {
                interface_inst* interf = (interface_inst*)actual;
                if (interf->Variables()) {
                  for (variables* var : *interf->Variables()) {
                    if (var->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(var);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(var);
                      }
                      previous = var;
                      found = true;
                      break;
                    }
                  }
                }
                if (interf->Modports()) {
                  for (modport* mport : *interf->Modports()) {
                    if (mport->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(mport);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(mport);
                      }
                      previous = mport;
                      found = true;
                      break;
                    }
                    if (mport->Io_decls()) {
                      for (io_decl* decl : *mport->Io_decls()) {
                        if (decl->VpiName() == name) {
                          any* actual = decl;
                          if (const any* exp = decl->Expr()) {
                            actual = (any*)exp;
                          }
                          if (actual->UhdmType() == uhdmref_obj) {
                            ref_obj* ref = (ref_obj*)actual;
                            if (const any* act = ref->Actual_group()) {
                              actual = (any*)act;
                            }
                          }
                          if (current->UhdmType() == uhdmref_obj) {
                            ((ref_obj*)current)->Actual_group(actual);
                          } else if (current->UhdmType() == uhdmbit_select) {
                            const any* parent = current->VpiParent();
                            ((bit_select*)current)->Actual_group(actual);
                            if (parent && (parent->UhdmType() == uhdmref_obj))
                              ((ref_obj*)parent)->Actual_group(actual);
                          }
                          previous = actual;
                          found = true;
                          break;
                        }
                      }
                    }
                    if (found) break;
                  }
                }
                if (interf->Nets()) {
                  for (nets* n : *interf->Nets()) {
                    if (n->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(n);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(n);
                      }
                      previous = n;
                      found = true;
                      break;
                    }
                  }
                }
                break;
              }
              case uhdmarray_var: {
                if (current->UhdmType() == uhdmmethod_func_call)
                  found = true;
                else if (current->UhdmType() == uhdmbit_select)
                  found = true;
                break;
              }
              case uhdmstring_var: {
                if (current->UhdmType() == uhdmmethod_func_call)
                  found = true;
                else if (current->UhdmType() == uhdmbit_select)
                  found = true;
                break;
              }
              case uhdmclass_typespec: {
                class_typespec* ctps = (class_typespec*)actual;
                any* tmp = bindClassTypespec(ctps, current, name, found);
                if (found) {
                  previous = tmp;
                }
                break;
              }
              case uhdmio_decl: {
                io_decl* decl = (io_decl*)actual;
                if (const typespec* tps = decl->Typespec()) {
                  UHDM_OBJECT_TYPE ttype = tps->UhdmType();
                  if (ttype == uhdmstring_typespec) {
                    found = true;
                  } else if (ttype == uhdmclass_typespec) {
                    class_typespec* ctps = (class_typespec*)tps;
                    any* tmp = bindClassTypespec(ctps, current, name, found);
                    if (found) {
                      previous = tmp;
                    }
                  } else if (ttype == uhdmstruct_typespec) {
                    struct_typespec* stpt = (struct_typespec*)tps;
                    for (typespec_member* member : *stpt->Members()) {
                      if (member->VpiName() == name) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(member);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  } else if (ttype == uhdmenum_typespec) {
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  } else if (ttype == uhdmunion_typespec) {
                    union_typespec* stpt = (union_typespec*)tps;
                    for (typespec_member* member : *stpt->Members()) {
                      if (member->VpiName() == name) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(member);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  }
                }
                if (decl->Ranges()) {
                  if (current->UhdmType() == uhdmmethod_func_call)
                    found = true;
                  else if (current->UhdmType() == uhdmbit_select)
                    found = true;
                }
                // TODO: class method support
                if (current->UhdmType() == uhdmmethod_func_call) found = true;
                break;
              }
              case uhdmparameter: {
                parameter* param = (parameter*)actual;
                if (const typespec* tps = param->Typespec()) {
                  UHDM_OBJECT_TYPE ttype = tps->UhdmType();
                  if (ttype == uhdmpacked_array_typespec) {
                    packed_array_typespec* ptps = (packed_array_typespec*)tps;
                    tps = (typespec*)ptps->Elem_typespec();
                    ttype = tps->UhdmType();
                  } else if (ttype == uhdmarray_typespec) {
                    array_typespec* ptps = (array_typespec*)tps;
                    tps = (typespec*)ptps->Elem_typespec();
                    ttype = tps->UhdmType();
                  }
                  if (ttype == uhdmstring_typespec) {
                    found = true;
                  } else if (ttype == uhdmclass_typespec) {
                    class_typespec* ctps = (class_typespec*)tps;
                    any* tmp = bindClassTypespec(ctps, current, name, found);
                    if (found) {
                      previous = tmp;
                    }
                  } else if (ttype == uhdmstruct_typespec) {
                    struct_typespec* stpt = (struct_typespec*)tps;
                    for (typespec_member* member : *stpt->Members()) {
                      if (member->VpiName() == name) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(member);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  } else if (ttype == uhdmenum_typespec) {
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  } else if (ttype == uhdmunion_typespec) {
                    union_typespec* stpt = (union_typespec*)tps;
                    for (typespec_member* member : *stpt->Members()) {
                      if (member->VpiName() == name) {
                        if (current->UhdmType() == uhdmref_obj) {
                          ((ref_obj*)current)->Actual_group(member);
                        } else if (current->UhdmType() == uhdmbit_select) {
                          const any* parent = current->VpiParent();
                          if (parent && (parent->UhdmType() == uhdmref_obj))
                            ((ref_obj*)parent)->Actual_group(member);
                        }
                        previous = member;
                        found = true;
                        break;
                      }
                    }
                    if (name == "name") {
                      // Builtin introspection
                      found = true;
                    }
                  }
                }
                if (param->Ranges()) {
                  if (current->UhdmType() == uhdmmethod_func_call)
                    found = true;
                  else if (current->UhdmType() == uhdmbit_select)
                    found = true;
                }
                break;
              }
              case uhdmoperation: {
                operation* op = (operation*)actual;
                if (op->VpiOpType() != vpiAssignmentPatternOp) {
                  break;
                }
                const typespec* tps = op->Typespec();
                if (!tps) {
                  break;
                }
                const struct_typespec* stps =
                    any_cast<const struct_typespec*>(tps);
                if (!stps) {
                  break;
                }
                std::vector<std::string> fieldNames;
                std::vector<const typespec*> fieldTypes;
                for (typespec_member* memb : *stps->Members()) {
                  fieldNames.push_back(memb->VpiName());
                  fieldTypes.push_back(memb->Typespec());
                }
                std::vector<any*> tmp(fieldNames.size());
                VectorOfany* orig = op->Operands();
                any* defaultOp = nullptr;
                any* res = nullptr;
                int index = 0;
                for (auto oper : *orig) {
                  if (oper->UhdmType() == uhdmtagged_pattern) {
                    tagged_pattern* tp = (tagged_pattern*)oper;
                    const typespec* ttp = tp->Typespec();
                    const std::string& tname = ttp->VpiName();
                    bool found = false;
                    if (tname == "default") {
                      defaultOp = oper;
                      found = true;
                    }
                    for (unsigned int i = 0; i < fieldNames.size(); i++) {
                      if (tname == fieldNames[i]) {
                        tmp[i] = oper;
                        found = true;
                        res = tmp[i];
                        break;
                      }
                    }
                    if (found == false) {
                      for (unsigned int i = 0; i < fieldTypes.size(); i++) {
                        if (ttp->UhdmType() == fieldTypes[i]->UhdmType()) {
                          tmp[i] = oper;
                          found = true;
                          res = tmp[i];
                          break;
                        }
                      }
                    }
                  } else {
                    if (index < (int)tmp.size()) {
                      tmp[index] = oper;
                      found = true;
                      res = tmp[index];
                    }
                  }
                  index++;
                }
                if (res == nullptr) {
                  if (defaultOp) {
                    res = defaultOp;
                  }
                }
                previous = res;
                break;
              }
              case uhdmref_var: {
                found = true;
                // TODO: class var support
                break;
              }
              default:
                // TODO: class method support
                if (current->UhdmType() == uhdmmethod_func_call) found = true;
                break;
            }
            if (!found) {
              // WIP:
              if ((!elaborator->muteErrors()) &&
                  (!elaborator->isInUhdmAllIterator()))
                serializer->GetErrorHandler()(
                    ErrorType::UHDM_UNRESOLVED_HIER_PATH, VpiName(), this,
                    nullptr);
            }
          } else {
            // WIP:
            if ((!elaborator->muteErrors()) &&
                (!elaborator->isInUhdmAllIterator()))
              serializer->GetErrorHandler()(
                  ErrorType::UHDM_UNRESOLVED_HIER_PATH, VpiName(), this,
                  nullptr);
          }
        } else if (previous->UhdmType() == uhdmtypespec_member) {
          typespec_member* member = (typespec_member*)previous;
          const typespec* tps = member->Typespec();
          if (tps) {
            UHDM_OBJECT_TYPE ttype = tps->UhdmType();
            if (ttype == uhdmpacked_array_typespec) {
              packed_array_typespec* ptps = (packed_array_typespec*)tps;
              tps = (typespec*)ptps->Elem_typespec();
              ttype = tps->UhdmType();
            } else if (ttype == uhdmarray_typespec) {
              array_typespec* ptps = (array_typespec*)tps;
              tps = (typespec*)ptps->Elem_typespec();
              ttype = tps->UhdmType();
            }
            if (ttype == uhdmstruct_typespec) {
              struct_typespec* stpt = (struct_typespec*)tps;
              for (typespec_member* member : *stpt->Members()) {
                if (member->VpiName() == name) {
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(member);
                    previous = member;
                    found = true;
                    break;
                  }
                }
              }
            } else if (ttype == uhdmunion_typespec) {
              union_typespec* stpt = (union_typespec*)tps;
              for (typespec_member* member : *stpt->Members()) {
                if (member->VpiName() == name) {
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(member);
                    previous = member;
                    found = true;
                    break;
                  }
                }
              }
            } else if (ttype == uhdmstring_typespec) {
              if (name == "len") {
                found = true;
              }
            }
          }
        } else if (previous->UhdmType() == uhdmarray_var) {
          array_var* avar = (array_var*)previous;
          VectorOfvariables* vars = avar->Variables();
          variables* actual = nullptr;
          if (vars && vars->size()) {
            actual = vars->at(0);
            UHDM_OBJECT_TYPE actual_type = actual->UhdmType();
            switch (actual_type) {
              case uhdmstruct_net:
              case uhdmstruct_var: {
                struct_typespec* stpt = nullptr;
                if (actual->UhdmType() == uhdmstruct_net) {
                  stpt = (struct_typespec*)((struct_net*)actual)->Typespec();
                } else if (actual->UhdmType() == uhdmstruct_var) {
                  stpt = (struct_typespec*)((struct_var*)actual)->Typespec();
                }
                if (stpt) {
                  for (typespec_member* member : *stpt->Members()) {
                    if (member->VpiName() == name) {
                      if (current->UhdmType() == uhdmref_obj) {
                        ((ref_obj*)current)->Actual_group(member);
                      } else if (current->UhdmType() == uhdmbit_select) {
                        const any* parent = current->VpiParent();
                        if (parent && (parent->UhdmType() == uhdmref_obj))
                          ((ref_obj*)parent)->Actual_group(member);
                      }
                      previous = member;
                      found = true;
                      break;
                    }
                  }
                }
                break;
              }
              default:
                break;
            }
          }
        } else if (previous->UhdmType() == uhdmstruct_var ||
                   previous->UhdmType() == uhdmstruct_net) {
          struct_typespec* stpt = nullptr;
          if (previous->UhdmType() == uhdmstruct_net) {
            stpt = (struct_typespec*)((struct_net*)previous)->Typespec();
          } else if (previous->UhdmType() == uhdmstruct_var) {
            stpt = (struct_typespec*)((struct_var*)previous)->Typespec();
          }
          if (stpt) {
            for (typespec_member* member : *stpt->Members()) {
              if (member->VpiName() == name) {
                if (current->UhdmType() == uhdmref_obj) {
                  ((ref_obj*)current)->Actual_group(member);
                } else if (current->UhdmType() == uhdmbit_select) {
                  const any* parent = current->VpiParent();
                  if (parent && (parent->UhdmType() == uhdmref_obj))
                    ((ref_obj*)parent)->Actual_group(member);
                }
                previous = member;
                found = true;
                break;
              }
            }
          }
        } else if (previous->UhdmType() == uhdmmodule) {
          module_inst* mod = (module_inst*)previous;
          if (mod->Variables()) {
            for (variables* var : *mod->Variables()) {
              if (var->VpiName() == name) {
                if (current->UhdmType() == uhdmref_obj) {
                  ((ref_obj*)current)->Actual_group(var);
                } else if (current->UhdmType() == uhdmbit_select) {
                  const any* parent = current->VpiParent();
                  if (parent && (parent->UhdmType() == uhdmref_obj))
                    ((ref_obj*)parent)->Actual_group(var);
                }
                previous = var;
                found = true;
                break;
              }
            }
          }

          if (mod->Nets()) {
            for (nets* n : *mod->Nets()) {
              if (n->VpiName() == name) {
                if (current->UhdmType() == uhdmref_obj) {
                  ((ref_obj*)current)->Actual_group(n);
                } else if (current->UhdmType() == uhdmbit_select) {
                  const any* parent = current->VpiParent();
                  if (parent && (parent->UhdmType() == uhdmref_obj))
                    ((ref_obj*)parent)->Actual_group(n);
                }
                previous = n;
                found = true;
                break;
              }
            }
          }
          if (mod->Modules()) {
            for (auto m : *mod->Modules()) {
              if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                found = true;
                previous = m;
                break;
              }
            }
          }
          break;
        } else if (previous->UhdmType() == uhdmgen_scope) {
          gen_scope* scope = (gen_scope*)previous;
          if (obj->UhdmType() == uhdmmethod_func_call) {
            method_func_call* call = (method_func_call*)current;
            if (scope->Task_funcs()) {
              for (auto tf : *scope->Task_funcs()) {
                if (tf->VpiName() == name) {
                  call->Function(any_cast<function*>(tf));
                  previous = (any*)call->Function();
                  found = true;
                  break;
                }
              }
            }
          } else if (obj->UhdmType() == uhdmmethod_task_call) {
            method_task_call* call = (method_task_call*)current;
            if (scope->Task_funcs()) {
              for (auto tf : *scope->Task_funcs()) {
                if (tf->VpiName() == name) {
                  call->Task(any_cast<task*>(tf));
                  found = true;
                  previous = (any*)call->Task();
                  break;
                }
              }
            }
          } else {
            if (scope->Modules()) {
              for (auto m : *scope->Modules()) {
                if (m->VpiName() == name || m->VpiName() == nameIndexed) {
                  found = true;
                  previous = m;
                  if (current->UhdmType() == uhdmref_obj) {
                    ((ref_obj*)current)->Actual_group(m);
                  } else if (current->UhdmType() == uhdmbit_select) {
                    const any* parent = current->VpiParent();
                    if (parent && (parent->UhdmType() == uhdmref_obj))
                      ((ref_obj*)parent)->Actual_group(m);
                  }
                  break;
                }
              }
            }
          }
        }
      }
      if (!found) previous = current;
    }
  }
  if (auto vec = VpiUses()) {
    auto clone_vec = serializer->MakeAnyVec();
    clone->VpiUses(clone_vec);
    for (auto obj : *vec) {
      clone_vec->push_back(obj->DeepClone(serializer, elaborator, clone));
    }
  }
  if (elaborator->uniquifyTypespec()) {
    if (auto obj = Typespec())
      clone->Typespec(obj->DeepClone(serializer, elaborator, clone));
  } else {
    if (auto obj = Typespec()) clone->Typespec((typespec*)obj);
  }

  return clone;
}
}  // namespace UHDM
