/*
 Do not modify, auto-generated by model_gen.tcl

 Copyright 2019 Alain Dargelas

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 * File:   vpi_user.cpp
 * Author:
 *
 * Created on December 14, 2019, 10:03 PM
 */
#include <string.h>
#include <strings.h>

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "include/sv_vpi_user.h"
#include "include/vhpi_user.h"

#include "headers/uhdm_types.h"
#include "headers/containers.h"
#include "headers/vpi_uhdm.h"
#include "headers/uhdm.h"
#include "headers/Serializer.h"

<HEADERS>

using namespace UHDM;

s_vpi_value* String2VpiValue(const std::string& s) {
  s_vpi_value* val = new s_vpi_value;
  val->format = 0;
  val->value.integer = 0;
  val->value.str = nullptr;
  size_t pos;
  if ((pos = s.find("INT:")) != std::string::npos) {
    val->format = vpiIntVal;
    val->value.integer = atoi(s.c_str() + pos + strlen("INT:"));
  }
  else if ((pos = s.find("SCAL:")) != std::string::npos) {
    val->format = vpiScalarVal;
    const char *const parse_pos = s.c_str() + pos + strlen("SCAL:");
    switch (parse_pos[0]) {
    case 'Z': val->value.integer = vpiZ; break;
    case 'X': val->value.integer = vpiX; break;
    case 'H': val->value.integer = vpiH; break;
    case 'L': val->value.integer = vpiL; break;
      // Not really clear what the difference between X and DontCare is.
      // Let's parse 'W'eak don't care as this one.
    case 'W': val->value.integer = vpiDontCare; break;
    default:
      if (strcasecmp(parse_pos, "DontCare") == 0) {
        val->value.integer = vpiDontCare;
      }
      else if (strcasecmp(parse_pos, "NoChange") == 0) {
        val->value.integer = vpiNoChange;
      }
      else {
        val->value.integer = atoi(parse_pos); // Maybe written numerically?
      }
      break;
    }
  }
  else if ((pos = s.find("BIN:")) != std::string::npos) {
    val->format = vpiBinStrVal;
    val->value.str = strdup(s.c_str() + pos + strlen("BIN:"));
  }
  else if ((pos = s.find("HEX:")) != std::string::npos) {
    val->format = vpiHexStrVal;
    val->value.str = strdup(s.c_str() + pos + strlen("HEX:"));
  }
  else if ((pos = s.find("OCT:")) != std::string::npos) {
    val->format = vpiOctStrVal;
    val->value.str = strdup(s.c_str() + pos + strlen("OCT:"));
  }
  else if ((pos = s.find("STRING:")) != std::string::npos) {
    val->format = vpiStringVal;
    val->value.str = strdup(s.c_str() + pos + strlen("STRING:"));
  }
  else if ((pos = s.find("REAL:")) != std::string::npos) {
    val->format = vpiRealVal;
    val->value.real = atof(s.c_str() + pos + strlen("REAL:"));
  }
  return val;
}


s_vpi_delay* String2VpiDelays(const std::string& s) {
  std::string scopy = s;
  s_vpi_delay* delay = new s_vpi_delay;
  delay->da = nullptr;
  if (strstr(scopy.c_str(), "#")) {
    scopy.erase(0,1);
    delay->da = new t_vpi_time;
    delay->no_of_delays = 1;
    delay->time_type = vpiScaledRealTime;
    delay->da[0].low  = atoi(scopy.c_str());
    delay->da[0].type = vpiScaledRealTime;
  }
  return delay;
}


std::string VpiValue2String(const s_vpi_value* value) {
  static const std::string kIntPrefix("INT:");
  static const std::string kScalPrefix("SCAL:");
  static const std::string kStrPrefix("STRING:");
  static const std::string kHexPrefix("HEX:");
  static const std::string kOctPrefix("OCT:");
  static const std::string kBinPrefix("BIN:");
  static const std::string kRealPrefix("REAL:");

  if (!value) return "";
  switch (value->format) {
  case vpiIntVal: return kIntPrefix + std::to_string(value->value.integer);
  case vpiScalarVal: {
    switch (value->value.scalar) {
    case vpi0: return "SCAL:0";
    case vpi1: return "SCAL:1";
    case vpiZ: return "SCAL:Z";
    case vpiX: return "SCAL:X";
    case vpiH: return "SCAL:H";
    case vpiL: return "SCAL:L";
    case vpiDontCare: return "SCAL:DontCare";
    case vpiNoChange: return "SCAL:NoChange";
    default:
      // mmh, some unknown number.
      return kScalPrefix + std::to_string(value->value.scalar);
    }
  }
  case vpiStringVal: return kStrPrefix + value->value.str;
  case vpiHexStrVal: return kHexPrefix + value->value.str;
  case vpiOctStrVal: return kOctPrefix + value->value.str;
  case vpiBinStrVal: return kBinPrefix + value->value.str;
  case vpiRealVal:  return kRealPrefix + std::to_string(value->value.real);
  }

  return "";
}


std::string VpiDelay2String(const s_vpi_delay* delay) {
  std::string result;
  if (delay == nullptr)
    return result;
  if (delay->da == nullptr)
    return result;
  switch (delay->time_type) {
  case vpiScaledRealTime: {
    return std::string(std::string("#") + std::to_string(delay->da[0].low));
    break;
  }
  default:
    break;
  }
  return result;
}

vpiHandle NewVpiHandle (const UHDM::BaseClass* object) {
  return reinterpret_cast<vpiHandle>(new uhdm_handle(object->UhdmType(), object));
}

/*
 * TODO: this way of new-ing handles is problematic as we generate new
 * objects that are never deleted, thus leaking memory.
 *
 * Goal should be to not have to allocate a shim-object but rather cast
 * our internal implementation pointer to vpiHandle.
 *
 * For most cases already, UHDM::BaseClass* would already fit the bill to
 * directly type-cast to vpiHandle which then is our opaque type we can cast
 * back to UHDM::BaseClass.
 *
 * Alas, we also use NewHandle() in a case where we don't have an object of
 * type BaseClass, thus we need the wrapper (see examples below in generated
 * code).
 *
 * So once we get that also onto some sort of super-base class (just a class
 * containing UhdmType() ?) we can fix this.
 */
static vpiHandle NewHandle (UHDM_OBJECT_TYPE type, const void *object) {
  return reinterpret_cast<vpiHandle>(new uhdm_handle(type, object));
}

vpiHandle vpi_handle_by_index (vpiHandle object,
                               PLI_INT32    indx) {
  return 0;
}

vpiHandle vpi_handle_by_name (PLI_BYTE8    *name,
                              vpiHandle    refHandle) {
  const uhdm_handle* const handle = (const uhdm_handle*) refHandle;
  const BaseClass* const object = (const BaseClass*) handle->object;
  <VPI_HANDLE_BY_NAME_BODY>
  return 0;
}

vpiHandle vpi_handle (PLI_INT32 type,
                      vpiHandle   refHandle) {
  const uhdm_handle* const handle = (const uhdm_handle*) refHandle;
  const BaseClass* const object = (const BaseClass*) handle->object;
  <VPI_HANDLE_BODY>
  std::cout << "VPI ERROR: Bad usage of vpi_handle" << std::endl;
  return 0;
}

vpiHandle vpi_handle_multi (PLI_INT32 type,
                            vpiHandle   refHandle1,
                            vpiHandle   refHandle2,
                            ... ) {
  return 0;
}

/* for traversing relationships */

vpiHandle vpi_iterate (PLI_INT32 type, vpiHandle refHandle) {
  const uhdm_handle* const handle = (const uhdm_handle*) refHandle;
  const BaseClass* const object = (const BaseClass*) handle->object;

  <VPI_ITERATE_BODY>
  std::cout << "VPI ERROR: Bad usage of vpi_iterate" << std::endl;
  return 0;
}

vpiHandle vpi_scan (vpiHandle iterator) {
  if (!iterator) return 0;
  uhdm_handle* handle = (uhdm_handle*) iterator;
  const void* vect = handle->object;
  <VPI_SCAN_BODY>
  return 0;
}

PLI_INT32 vpi_free_object (vpiHandle object) {
  return vpi_release_handle(object);
}

PLI_INT32 vpi_release_handle (vpiHandle object) {
  delete (uhdm_handle*) object;
  return 0;
}

/* for processing properties */

PLI_INT32 vpi_get (PLI_INT32   property,
                   vpiHandle   object) {
  if (!object) {
      std::cout << "VPI ERROR: Bad usage of vpi_get" << std::endl;
    return 0;
  }

  // At this point, the implementation is exactly the same as for 64 bit,
  // but we truncate.
  return (PLI_INT32) vpi_get64(property, object);
}

PLI_INT64 vpi_get64 (PLI_INT32 property,
                     vpiHandle   object) {
  if (!object) {
      std::cout << "VPI ERROR: Bad usage of vpi_get64" << std::endl;
    return 0;
  }

  const uhdm_handle* const handle = (const uhdm_handle*) object;
  const BaseClass*  const obj = (const BaseClass*) handle->object;

  // Baseclass-handled properties; all the others still need to be handled
  // separately, but this is a good start.
  switch (property) {
    case vpiLineNo: return obj->VpiLineNo();
    case vpiType: return obj->VpiType();
  }

  // ... all other properties currently handled 'manually' for now
<VPI_GET_BODY>

  return 0;
}

PLI_BYTE8 *vpi_get_str (PLI_INT32 property,
                        vpiHandle   object) {
  if (!object) {
    std::cout << "VPI ERROR: Bad usage of vpi_get_str" << std::endl;
    return 0;
  }
  const uhdm_handle* const handle = (const uhdm_handle*) object;
  const BaseClass*  const obj = (const BaseClass*) handle->object;

  // Handle some easy cases first; these are handled in the BaseClass.
  // TODO: add some specific property interfaces (VpiFullNameImplementor?)
  // to access some other common properties.
  switch (property) {
    case vpiFile:
      return (PLI_BYTE8*) (obj->VpiFile().empty()
                           ? 0
                           : obj->VpiFile().c_str());

   case vpiName:
     return (PLI_BYTE8*) (obj->VpiName().empty()
                          ? 0
                          : obj->VpiName().c_str());

    case vpiDefName:
      return (PLI_BYTE8*) (obj->VpiDefName().empty()
                           ? 0
                           : obj->VpiDefName().c_str());
  }

  // ... all other properties currently handled 'manually' for now
  <VPI_GET_STR_BODY>

  return 0;
}


/* delay processing */

void vpi_get_delays (vpiHandle object,
                     p_vpi_delay delay_p) {
  if (!object) {
    std::cout << "VPI ERROR: Bad usage of vpi_get_delay" << std::endl;
  }
  const uhdm_handle* const handle = (const uhdm_handle*) object;
  const BaseClass*  const obj = (const BaseClass*) handle->object;
  delay_p->da = nullptr;
  <VPI_GET_DELAY_BODY>
}

void vpi_put_delays (vpiHandle object,
                     p_vpi_delay delay_p) {
}

/* value processing */

void vpi_get_value (vpiHandle vexpr,
                    p_vpi_value value_p) {
  if (!vexpr) {
    std::cout << "VPI ERROR: Bad usage of vpi_get_value" << std::endl;
  }
  const uhdm_handle* const handle = (const uhdm_handle*) vexpr;
  const BaseClass*  const obj = (const BaseClass*) handle->object;
  value_p->format = 0;
  <VPI_GET_VALUE_BODY>
}

vpiHandle vpi_put_value (vpiHandle object,
                         p_vpi_value value_p,
                         p_vpi_time time_p,
                         PLI_INT32 flags) {
  return 0;
}

void vpi_get_value_array (vpiHandle object,
                          p_vpi_arrayvalue arrayvalue_p,
                          PLI_INT32 *index_p,
                          PLI_UINT32 num) {
}

void vpi_put_value_array (vpiHandle object,
                          p_vpi_arrayvalue arrayvalue_p,
                          PLI_INT32 *index_p,
                          PLI_UINT32 num) {
}

/* time processing */

void vpi_get_time(vpiHandle object,
                  p_vpi_time time_p) {
}


PLI_INT32 vpi_get_data (PLI_INT32 id,
                        PLI_BYTE8 *dataLoc,
			PLI_INT32 numOfBytes) {
  return 0;
}

PLI_INT32 vpi_put_data (PLI_INT32 id,
                        PLI_BYTE8 *dataLoc,
			PLI_INT32 numOfBytes) {
  return 0;
}

void *vpi_get_userdata (vpiHandle obj) {
  return 0;
}

PLI_INT32 vpi_put_userdata (vpiHandle obj,
                            void *userdata) {
  return 0;
}

vpiHandle vpi_handle_by_multi_index (vpiHandle obj,
                                     PLI_INT32 num_index,
                                     PLI_INT32 *index_array) {
  return 0;
}
